---
layout: page
title: Discord Bot Projects
subtitle: Open Source Discord Bots
---
> # DragSim
> Fully Functional Ticket Bot that replicates Ticket Tool

> # Multi-Step Ticket for server administration

> - Create a ticket with a button
> - "Discord Modal" system for forms

```python
class ticketModal(discord.ui.Modal):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)

        self.add_item(discord.ui.InputText(label="Reason", style=discord.InputTextStyle.long))

    def variables(self, user, channel):
        self.user = user
        self.channel = channel

    async def callback(self, interaction: discord.Interaction):

        await interaction.response.send_message(f"Ticket opened successfully at {self.channel.mention}", ephemeral=True)

        embed = discord.Embed(title="Support Ticket Opened!", description="Thank you for contacting support.\nPlease describe your intent for the ticket and wait for a response.", color=BLUE_COLOR)
        embed.add_field(name="Ticket Reason", value=self.children[0].value, inline=False)
        embed.set_footer(icon_url=interaction.guild.icon.url, text="Powered by dragsim.org")
        closeButton = Button(style=discord.ButtonStyle.red, custom_id="close", label=" Close Ticket", emoji="üîí")
        closeView = View()
        closeView.add_item(closeButton)
        await self.channel.send(embed=embed, view=closeView)

        async def close_callback(interaction:discord.Interaction):     
            overwrite = discord.PermissionOverwrite()
            overwrite.send_messages = False
            overwrite.read_messages = False
            
            with open('opentickets.json', 'r') as opener:
                openTickets = json.load(opener)

            intStaff = False
            for j, k in enumerate(interaction.user.roles):
                if k.name == "Staff":
                    intStaff = True
            isOPEN = False
            for i, dictionary in enumerate(openTickets):
                if dictionary['user'] == interaction.user.id:
                    creatorNum = i
                    CREATOR = bing.get_user(dictionary['user'])
                    await interaction.channel.set_permissions(CREATOR, overwrite=overwrite)
                    isOPEN = True
                    break
            if isOPEN:
                user_messages = await interaction.channel.history(limit=None).flatten()
                file = open("messages.txt", "w")
                user_messages.reverse()
                for item in user_messages:
                    try:
                        file.write(f"[{item.created_at.strftime('%m/%d/%Y, %H:%M:%S')}] {item.author.name}#{item.author.discriminator}: {item.content}\n")
                    except:
                        pass
                file.close()
                opener = bing.get_user(openTickets[creatorNum]['user'])
                transcript_channel = bing.get_channel("[REDACTED]")
                sendEmbed = discord.Embed(title="Ticket Closed", color=BLUE_COLOR)
                sendEmbed.set_author(name="DragSim", url=interaction.guild.icon.url)
                sendEmbed.add_field(name="üî¢ Ticket ID", value=openTickets[creatorNum]['ticket'])
                sendEmbed.add_field(name="‚úÖ Opened By", value=opener.mention)
                sendEmbed.add_field(name="üîí Closed By", value=interaction.user.mention)
                sendEmbed.add_field(name="üïê Open Time", value=f"<t:{int(openTickets[creatorNum]['time'])}:f>")
                sendEmbed.add_field(name="‚ùì Reason", value=self.children[0].value)
                sendEmbed.timestamp = datetime.now()
                await transcript_channel.send(embed=sendEmbed, file=discord.File("messages.txt"))
                openTickets.pop(creatorNum)
                with open('opentickets.json', 'w') as outfile:
                    outfile.write(json.dumps(openTickets))
                try:
                    await opener.send(embed=sendEmbed, file=discord.File("messages.txt"))
                except:
                    pass

                embed = discord.Embed(title=f"Transcript Generated for #{interaction.channel}", color=0xFFC300)
                await interaction.response.send_message(embed=embed)
            else:
                await interaction.response.send_message("Attempting to close ticket...", ephemeral=True)
            if intStaff:
                embed = discord.Embed(title=f"Closing Ticket in 5 seconds", color=0xFD9C9C)
                await interaction.channel.send(embed=embed)
                await asyncio.sleep(5)
                await self.channel.delete()

        closeButton.callback = close_callback
```

# VerifyBing Discord Bot

> Purpose is to send a randomly generated string on an image generated by the Pillow library to complete verification

```python
@bing.command()
@commands.cooldown(1, 60, commands.BucketType.user)
async def verify(ctx):
  if ctx.channel.id == 997702424556998796:
    CHARS = "ABCDEFGHJKLMNOPQRSTUVWXYZ"
    VERIFICATION_CODE = ""
    for i in range(0,5):
      num = random.randint(0,24)
      VERIFICATION_CODE += CHARS[num]
    img = Image.open("akatsuki.png")
    font = ImageFont.truetype("HIROMISAKE.ttf", 300)
    draw = ImageDraw.Draw(img)
    width = 520
    text=VERIFICATION_CODE
    w, h = draw.textsize(text)
    draw.text(((width-w), 450), text, (0,0,0), font=font, align="center")
    img.save("prof.png")
    try:
      await ctx.author.send("Please respond to the following Captcha with the correct combination of letters", file=discord.File("prof.png"))
    except:
      await ctx.reply("Please enable: Allow direct messages from server members")
      return
    mod_channel = bing.get_channel(997680601899470858)
    embed = discord.Embed(color=pink_color)
    embed.set_author(name="Captcha Sent", icon_url=ctx.author.avatar_url)
    embed.add_field(name="User", value=ctx.author)
    embed.set_footer(text=f"User ID: {ctx.author.id}")
    await mod_channel.send(embed=embed)

    def check(msg):
      return msg.content.upper() == VERIFICATION_CODE and str(msg.channel) == f"Direct Message with {ctx.author}"
  
    msg = await bing.wait_for("message", check=check, timeout=30)
  
    if msg.content.upper() == VERIFICATION_CODE:
      embed = discord.Embed(description=f"**üîë {ctx.author.mention} has completed the Captcha**", color=green_color)
      embed.set_author(name=ctx.author, icon_url=ctx.author.avatar_url)
      embed.set_footer(text=f"User ID: {ctx.author.id}")
      await mod_channel.send(embed=embed)
      await ctx.author.add_roles(ctx.guild.get_role(997673788097437706))
      await msg.reply(f"Successfully verified in **{ctx.guild}**")
  else:
    await ctx.reply("You cannot execute the command in this channel")
```


> # Master Oogway Bot

> - Uses Hypixel's API, SlothPixel API, and SlothPixel API
> - SlothPixel API confirms if the user's Discord is connected to the specified Hypixel Account
> - Senither API confirms user's average skill level it checks if it meets server expectations


```python
@bing.command()
async def verify(ctx, ign=None):
  CONTINUATION = True
  for x in ctx.author.roles:
    if x.id == "[REDACTED]":
      CONTINUATION = False
      break
    else:
      continue
  if CONTINUATION is True:
    if ign != None:
      try:
        user_name = requests.get(f"https://api.mojang.com/users/profiles/minecraft/{ign}").json()
        link = f"https://api.slothpixel.me/api/players/{ign}"
        data = getInfo(link)
        user_discord = data['links']['DISCORD']
        if user_discord == str(ctx.author):
          uuid = user_name["id"]
          profile_link = f"https://api.hypixel.net/skyblock/profiles?key={KEY}&uuid={uuid}"
          sb_data = getInfo(profile_link)
          link = f"https://api.hypixel.net/player?key={KEY}&uuid={uuid}"
          data = getInfo(link)
          senither = f"https://hypixel-api.senither.com/v1/profiles/{uuid}?key={KEY}"
          senither_data = getInfo(senither)
          save = 9999999999999999999
          for x in range(0, len(sb_data['profiles'])):
            for y in sb_data['profiles'][x]['members']:
              if uuid == y:
                difference = time.time() - sb_data['profiles'][x]['members'][y]['last_save']
                if difference < save:
                  save = sb_data['profiles'][x]['members'][y]['last_save']
                  profile_id = sb_data['profiles'][x]['profile_id']
  
          for z in range(0,len(sb_data['profiles'])):
            if sb_data['profiles'][z]['profile_id'] == profile_id:
              profile_num = z
  
          profile_name = data['player']['stats']['SkyBlock']['profiles'][profile_id]["cute_name"]
```